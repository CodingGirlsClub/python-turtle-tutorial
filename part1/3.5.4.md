### 名称空间

本节目标：
- 了解LEGB名称空间。
- 能指出之前写过的程序中的变量都属于哪个名称空间。
- 了解闭包。

当我们使用turtle库中的类时，我们用`turtle.Turtle`。为什么要把库名加上？
原因很容易想到，因为别的库中也可能有`Turtle`。
```python
y = 3
def func():
    y = 1
    print("函数func：", y) # 输出：1
func()
print("函数外：", y) # 输出：3
```
运行以上代码我们发现，在函数里面对`y`的值进行改变似乎没有影响到函数外`y`的值。

**Learning By Reading 难度：★★ 重要性：★★★★★**

- 阅读材料，了解[Python的命名空间](https://segmentfault.com/a/1190000004519811)。
- 材料中有一个[链接](https://segmentfault.com/a/1190000004461404)很好地解释了“闭包”的概念。
里面提到的“装饰器”将在下一节介绍，可以先跳过与“装饰器”有关的部分。

另一个例子，
```python
def polygon_factory(n):
    # 返回一个正n边形函数polygon
    def polygon(turtle, side):
        return turtle.polygon(n, side) # 绑定了闭包polygon_factory中的名称n和局部名称空间中的turtle和side
        # 翻译成人话即这里的n用的是polygon_factory的参数n，而turtle和side是局部变量
    return polygon

pentagon = polygon_factory(5) # 五边形函数
octagon = polygon_factory(8) # 八边形函数
my_turtle = MyTurtle()
pentagon(my_turtle, 50) # 边长为50的五边形
octagon(my_turtle, 50) # 边长为50的八边形
```

每个名称都有自己的“作用域”（scope），即这个名称可以在哪个范围内被绑定。
比如上面的`turtle`和`side`，其作用域是`polygon`这个函数。
出了这个函数，Python就不认`turtle`和`side`这个名字了。
而`polygon`和`n`，其作用域是`polygon_factory`这个函数，也包括在`polygon_factory`里面定义的`polygon`函数。
```python
def polygon_factory(n):
    def polygon(turtle, side):
        print(n, polygon) # 可以
        print(turtle, side) # 可以
        return turtle.polygon(n, side)
    print(n, polygon) # 可以
    print(turtle) # 报错
    print(side) # 报错
    return polygon
```

而靠里面的名称会覆盖掉靠外面的名称，本节第一段代码就是例子。

另外一点需要注意的是，函数体中的名称，其作用域可以扩展到函数中定义的函数里。
就像上面的`n`可以在`polygon`中使用。

但类体中的名称不会扩展到类方法和列表解析中。
```python
x = 1
class BianBuChuLaiMingZiLe(object):
    y = 1
    z = [y for i in range(10)] # 不可以
    print(x) # 可以
    print(y) # 可以
    x = 3
    z = [x for i in range(3)] # 可以，但这里的x是全局变量x，即最上面等于1的那个x，z等于[1]
    def some_method(self):
        print(x) # 可以
        print(y) # 报错
```
即`x`的作用域延伸到了`some_method`里，但`y`的作用域不能。

另一个区别是
```python
x = 5

def some_function():
    y = x # 报错：UnboundLocalError，Python认为x这时候还没有赋值
    x = 3

class SomeClass(object):
    y = x # 可以
    x = 3

print(SomeClass.x) # 输出：3
print(SomeClass.y) # 输出：5
print(x) # 输出：5
```
在函数中，只要用到了变量`x`，那么，函数体中的所有`x`都会被绑定到局部名称空间的`x`，
所以`y = x`的时候会报错说“变量`x`在赋值前引用”。

而类体中，遇到这种情况时，Python会自己去全局名称空间里面找`x`。
```python
x = 5

def f():
    x = 3

    class _A(object):
        y = x # 由于局部名称空间中存在x，所以会有UnboundLocalError，但这是类体，所以Python会去全局名称空间找x，找到全局空间中的x是5
        x = 9

    return _A

A = f()
print(A.x, A.y) # 输出：9，5
```
